<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>SMG Object Database Editor</title>
<style>
body {
    font-family: sans-serif;
    background: #1e1e1e;
    color: #ddd;
    margin: 0;
}
header {
    background: #2c2c2c;
    padding: 10px;
    display: flex;
    gap: 10px;
}
main {
    display: flex;
    height: calc(100vh - 50px);
}
#sidebar {
    width: 30%;
    background: #252525;
    display: flex;
    flex-direction: column;
}
#tabs, #adds {
    display: flex;
}
#tabs button {
    flex: 1;
    background: #333;
    border: none;
    color: white;
    padding: 8px;
}
#tabs button.active {
    background: #3a6ea5;
}
#list {
    flex: 1;
    overflow-y: auto;
}
#list div {
    padding: 8px;
    border-bottom: 1px solid #333;
    cursor: pointer;
}
#list div:hover {
    background: #333;
}
#list .active {
    background: #3a6ea5;
}
#editor {
    flex: 1;
    padding: 15px;
    overflow-y: auto;
}
label {
    display: block;
    margin-top: 8px;
}
input, select, textarea {
    width: 100%;
    background: #333;
    color: white;
    border: 1px solid #555;
    padding: 4px;
}
fieldset {
    border: 1px solid #444;
    margin-top: 12px;
}
legend {
    color: #aaa;
}
button {
    margin-top: 8px;
    padding: 6px 10px;
    border: none;
    color: white;
    background: #3a6ea5;
}
button.danger {
    background: #a53a3a;
}
.valueRow {
    display: flex;
    gap: 6px;
    margin-top: 5px;
}
.valueRow input {
    flex: 1;
}
</style>
</head>
<body>

<header>
    <input type="file" id="fileInput" accept=".json">
    <button onclick="downloadJSON()">Download JSON</button>
</header>

<main>
<div id="sidebar">
    <div id="tabs">
        <button id="objectsTab" class="active" onclick="switchTab('objects')">Objects</button>
        <button id="classesTab" onclick="switchTab('classes')">Classes</button>
    </div>
    <div id="adds">
      <button id="addObject" onclick="addObject()">Add Object</button>
      <button id="addClass" onclick="addClass()">Add Class</button>
    </div>
    <div id="list"></div>
</div>

<div id="editor"></div>
</main>

<script>
let db = null;
let mode = "objects";
let selectedIndex = null;
let selectedParam = null;

const objectFieldSchema = {
  InternalName: { type: "text" },
  ClassNameSMG1: {
    type: "select",
    dynamicOptions: "classes"
  },
  ClassNameSMG2: {
    type: "select",
    dynamicOptions: "classes"
  },
  Name: { type: "text" },
  Notes: { type: "textarea" },

  Category: {
    type: "select",
    options: [
      "stagepart","levelfeature","background","enemy","boss","npc",
      "item","particle","areas","gravity","cutscene","controller","deprecated"
    ]
  },

  AreaShape: {
    type: "select",
    options: [
      "Any","Sphere","BaseOriginCube","Cylinder",
      "CenterOriginCube","Bowl"
    ]
  },

  ListSMG1: {
    type: "select",
    options: [
      "MapPartsInfo","ObjInfo","AreaObjInfo","CameraCubeInfo",
      "ChildObjInfo","DemoObjInfo","PlanetObjInfo",
      "StartInfo","SoundInfo",""
    ]
  },

  ListSMG2: {
    type: "select",
    options: [
      "MapPartsInfo","ObjInfo","AreaObjInfo","CameraCubeInfo",
      "ChildObjInfo","DemoObjInfo","PlanetObjInfo",
      "StartInfo","SoundInfo",""
    ]
  },

  File: {
    type: "select",
    options: ["Map","Sound","Design"]
    
  },

  Games: {
    type: "select",
    options: [
      { v: 1, t: "SMG1" },
      { v: 2, t: "SMG2" },
      { v: 3, t: "Both" }
    ]
  },

  Progress: {
    type: "select",
    options: [
      { v: 0, t: "Not understood" },
      { v: 1, t: "Partially understood" },
      { v: 2, t: "Fully understood" }
    ]
  },

  IsUnused: { type: "checkbox" },
  IsLeftover: { type: "checkbox" }
};

const objectFilters = {
  class: "",
  game: "",
  category: "",
  unused: false,
  leftover: false,
  search: "",
  progress: "",
  file: ""
};

function getObjectsForClass(classInternalName) {
  if (!db || !db.Objects) return [];

  return db.Objects.filter(o =>
    o.ClassNameSMG1 === classInternalName ||
    o.ClassNameSMG2 === classInternalName
  ).map(o => ({
    v: o.InternalName,
    t: o.Name ? `${o.Name} (${o.InternalName})` : o.InternalName
  }));
}

function debounce(fn, wait = 300) {
  let t;
  return (...args) => {
    clearTimeout(t);
    t = setTimeout(() => fn(...args), wait);
  };
}

fileInput.onchange = e => {
    const r = new FileReader();
    r.onload = () => {
        db = JSON.parse(r.result);
        renderList();
    };
    r.readAsText(e.target.files[0]);
};

function getClassOptions() {
  if (!db || !db.Classes) return [];

  return db.Classes.map(c => ({
    v: c.InternalName,
    t: c.Name ? `${c.Name} (${c.InternalName})` : c.InternalName
  }));
}


function switchTab(m) {
    mode = m;
    selectedIndex = null;
    selectedParam = null;
    objectsTab.classList.toggle("active", m === "objects");
    classesTab.classList.toggle("active", m === "classes");
    renderList();
    editor.innerHTML = "";
}

/*
function renderList() {
    list.innerHTML = "";
    
}
*/

function renderList() {
  list.innerHTML = "";

  if (mode === "objects") {
    renderObjectFilters();
    renderFilteredObjects();
  } else {
    renderClasses();
  }
}

function renderClasses() {
  const arr = db.Classes;
    arr.forEach((e, i) => {
        const d = document.createElement("div");
        d.textContent = e.Name || e.InternalName;
        d.onclick = () => loadEntry(i);
        if (i === selectedIndex) d.classList.add("active");
        list.appendChild(d);
    });
}

function renderObjectFilters() {
  const filterDiv = document.createElement("div");
  filterDiv.style.padding = "8px";
  filterDiv.style.borderBottom = "1px solid #333";

  filterDiv.innerHTML = `
<label>Class
  <select id="filterClass">
    <option value="">All</option>
    ${getClassOptions().map(c =>
      `<option value="${c.v}">${c.t}</option>`
    ).join("")}
  </select>
</label>

<label>Game
  <select id="filterGame">
    <option value="">All</option>
    <option value="1">SMG1</option>
    <option value="2">SMG2</option>
    <option value="3">Both</option>
  </select>
</label>

<label>Category
  <select id="filterCategory">
    <option value="">All</option>
    ${objectFieldSchema.Category.options.map(c =>
      `<option value="${c}">${c}</option>`
    ).join("")}
  </select>
</label>

<label>Progress
  <select id="filterProgress">
    <option value="">All</option>
    <option value="0">Not understood</option>
    <option value="1">Partially understood</option>
    <option value="2">Fully understood</option>
  </select>
</label>

<label>File
  <select id="filterFile">
    <option value="">All</option>
    <option value="Map">Map</option>
    <option value="Sound">Sound</option>
    <option value="Design">Design</option>
  </select>
</label>

<label>
  <input type="checkbox" id="filterUnused"> Unused
</label>

<label>
  <input type="checkbox" id="filterLeftover"> Leftover
</label>

<label>Search
  <input id="filterSearch" placeholder="Name or internal name">
</label>
`;

  list.appendChild(filterDiv);

  // Restore state
  filterClass.value = objectFilters.class;
  filterGame.value = objectFilters.game;
  filterCategory.value = objectFilters.category;
  filterProgress.value = objectFilters.progress;
  filterUnused.checked = objectFilters.unused;
  filterFile.value = objectFilters.file;
  filterLeftover.checked = objectFilters.leftover;
  filterSearch.value = objectFilters.search;

  // Event bindings
  filterClass.onchange = e => {
    objectFilters.class = e.target.value;
    renderList();
  };
  filterGame.onchange = e => {
    objectFilters.game = e.target.value;
    renderList();
  };
  filterCategory.onchange = e => {
    objectFilters.category = e.target.value;
    renderList();
  };
  filterProgress.onchange = e => {
    objectFilters.progress = e.target.value;
    renderList();
  };
  filterFile.onchange = e => {
    objectFilters.file = e.target.value;
    renderList();
  };
  filterUnused.onchange = e => {
    objectFilters.unused = e.target.checked;
    renderList();
  };
  filterLeftover.onchange = e => {
    objectFilters.leftover = e.target.checked;
    renderList();
  };
  const debouncedRender = debounce(renderList, 2000);
  filterSearch.addEventListener('input', e => {
    objectFilters.search = e.target.value.trim().toLowerCase();
    debouncedRender();
  });
}

function renderFilteredObjects() {
  const filtered = db.Objects.filter(o => {
    // Class filter
    if (objectFilters.class &&
        o.ClassNameSMG1 !== objectFilters.class &&
        o.ClassNameSMG2 !== objectFilters.class)
      return false;

    // Game filter
    if (objectFilters.game &&
        String(o.Games) !== objectFilters.game)
      return false;

    // Category filter
    if (objectFilters.category &&
        o.Category !== objectFilters.category)
      return false;
    
    // Progress filter
    if (objectFilters.progress &&
        o.Progress !== Number(objectFilters.progress))
      return false;
    
    // File filter
    if (objectFilters.file &&
        o.File !== objectFilters.file)
      return false;

    // Unused filter
    if (objectFilters.unused && !o.IsUnused)
      return false;

    // Leftover filter
    if (objectFilters.leftover && !o.IsLeftover)
      return false;

    // Text search
    if (objectFilters.search) {
      const hay = `${o.Name || ""} ${o.InternalName || ""}`.toLowerCase();
      if (!hay.includes(objectFilters.search))
        return false;
    }

    return true;
  });

  filtered.forEach(o => {
    const idx = db.Objects.indexOf(o);
    const d = document.createElement("div");
    d.textContent = o.Name || o.InternalName;
    if (idx === selectedIndex) d.classList.add("active");
    d.onclick = () => loadEntry(idx);
    list.appendChild(d);
  });
}

function loadEntry(i) {
    selectedIndex = i;
    selectedParam = null;
    renderList();
    editor.innerHTML = "";
    mode === "objects" ? editObject() : editClass();
}

/* ================= OBJECT EDITOR ================= */

function addObject() {
  const obj = {
    InternalName: "NewObject",
    Name: "New Object",
    Games: 3,
    Progress: 0,
    IsUnused: false,
    IsLeftover: false
  };
  db.Objects.push(obj);
  renderList();
}

function deleteObject() {
  if (selectedIndex === null) return;
  if (!confirm("Delete this object?")) return;
  db.Objects.splice(selectedIndex, 1);
  selectedIndex = null;
  document.getElementById("editor").classList.add("hidden");
  renderList();
}

function addClass() {
  const obj = {
    InternalName: "NewClass",
    Name: "New Class",
    Games: 3,
    Progress: 0,
    Parameters: {}
  };
  db.Classes.push(obj);
  renderList();
}

function deleteClass() {
  if (selectedIndex === null) return;
  if (!confirm("Delete this class?")) return;
  db.Classes.splice(selectedIndex, 1);
  selectedIndex = null;
  document.getElementById("editor").classList.add("hidden");
  renderList();
}

function editObject() {
  const o = db.Objects[selectedIndex];
  editor.innerHTML = `<h2>Object</h2>`;

  for (const [key, def] of Object.entries(objectFieldSchema)) {
    const value = o[key];

    if (def.type === "text") {
      editor.innerHTML += `
      <label>${key}
        <input id="obj_${key}" value="${value ?? ""}">
      </label>`;
    }

    if (def.type === "textarea") {
      editor.innerHTML += `
      <label>${key}
        <textarea id="obj_${key}">${value ?? ""}</textarea>
      </label>`;
    }

    if (def.type === "checkbox") {
      editor.innerHTML += `
      <label>
        <input type="checkbox" id="obj_${key}" ${value ? "checked" : ""}>
        ${key}
      </label>`;
    }

    if (def.type === "select") {
      let options = [];

      if (def.dynamicOptions === "classes") {
        options = [{ v: "", t: "(none)" }, ...getClassOptions()];
      } else {
        options = def.options.map(o2 =>
          typeof o2 === "string"
            ? { v: o2, t: o2 || "(none)" }
            : o2
        );
      }

      editor.innerHTML += `
      <label>${key}
        <select id="obj_${key}">
          ${options.map(o2 =>
            `<option value="${o2.v}">${o2.t}</option>`
          ).join("")}
        </select>
      </label>`;
    }
  }

  editor.innerHTML += `
    <button onclick="saveObject()">Save Object</button>
    <button class="danger" onclick="deleteObject()">Delete Object</button>
  `;

  // Set select values AFTER insertion
  for (const key of Object.keys(objectFieldSchema)) {
    const el = document.getElementById(`obj_${key}`);
    if (!el || o[key] === undefined) continue;
    el.value = o[key];
  }
}

function saveObject() {
  const o = db.Objects[selectedIndex];

  for (const [key, def] of Object.entries(objectFieldSchema)) {
    const el = document.getElementById(`obj_${key}`);
    if (!el) continue;

    if (def.type === "checkbox") {
      o[key] = el.checked;
    } else if (el.value === "") {
      delete o[key];
    } else {
      o[key] = (def.type === "select" && !isNaN(el.value))
        ? Number(el.value)
        : el.value;
    }
  }

  renderList();
}

/* ================= CLASS + PARAMETER EDITOR ================= */

function editClass() {
    const c = db.Classes[selectedIndex];
    editor.innerHTML = `<h2>Class</h2>

<label>Internal Name
<input id="clsInternal" value="${c.InternalName || ""}">
</label>

<label>Name
<input id="clsName" value="${c.Name || ""}">
</label>

<label>Notes
<textarea id="clsNotes">${c.Notes || ""}</textarea>
</label>

<button onclick="saveClass()">Save Class</button>
<button onclick="deleteClass()" class="danger">Delete Class</button>

<fieldset>
<legend>Parameters</legend>
<div id="paramList"></div>
<button onclick="addParameter()">Add Parameter</button>
</fieldset>

<div id="paramEditor"></div>
`;

    renderParameters();
}

function saveClass() {
    const c = db.Classes[selectedIndex];
    c.InternalName = clsInternal.value;
    c.Name = clsName.value;
    c.Notes = clsNotes.value;
    renderList();
}

function renderParameters() {
    const c = db.Classes[selectedIndex];
    paramList.innerHTML = "";
    if (!c.Parameters) c.Parameters = {};

    Object.keys(c.Parameters).forEach(p => {
        const d = document.createElement("div");
        d.textContent = p;
        d.onclick = () => editParameter(p);
        paramList.appendChild(d);
    });
}

function addParameter() {
    const name = prompt("Internal parameter name (e.g. Obj_arg0)");
    if (!name) return;
    db.Classes[selectedIndex].Parameters[name] = {
        Name: "",
        Games: 3,
        Needed: false,
        Description: "",
        Values: [],
        Exclusives: []
    };
    renderParameters();
    editParameter(name);
}

function editParameter(name) {
    selectedParam = name;
    const p = db.Classes[selectedIndex].Parameters[name];

    paramEditor.innerHTML = `
<fieldset>
<legend>
Parameter: ${name}
${p.Exclusives?.length ? " ⚠ limited" : ""}
</legend>

<label>Readable Name
<input id="pName" value="${p.Name || ""}">
</label>

<label>Games
<select id="pGames">
<option value="1">SMG1</option>
<option value="2">SMG2</option>
<option value="3">Both</option>
</select>
</label>

<label>
<input type="checkbox" id="pNeeded" ${p.Needed ? "checked" : ""}> Needed
</label>

<label>Description
<textarea id="pDesc">${p.Description || ""}</textarea>
</label>

<h4>Values</h4>
<div id="values"></div>
<button onclick="addValue()">Add Value</button>

<button onclick="saveParameter()">Save Parameter</button>
<button class="danger" onclick="deleteParameter()">Delete Parameter</button>

<h4>Exclusives (only these objects use this parameter)</h4>
<div id="exclusiveHint" style="font-size:0.85em;color:#aaa;">
  If empty, all objects of this class use the parameter.
</div>
<select id="pExclusives" multiple size="6"></select>

</fieldset>
`;

    pGames.value = p.Games;
    renderValues();
    renderExclusives();
}

function renderValues() {
    const p = db.Classes[selectedIndex].Parameters[selectedParam];
    values.innerHTML = "";
    p.Values.forEach((v, i) => {
        values.innerHTML += `
<div class="valueRow">
<input value="${v.Value}">
<input value="${v.Notes || ""}">
<button onclick="removeValue(${i})">✖</button>
</div>`;
    });
}

function renderExclusives() {
  const c = db.Classes[selectedIndex];
  const p = c.Parameters[selectedParam];
  const sel = document.getElementById("pExclusives");

  sel.innerHTML = "";

  const options = getObjectsForClass(c.InternalName);

  options.forEach(o => {
    const opt = document.createElement("option");
    opt.value = o.v;
    opt.textContent = o.t;
    if (p.Exclusives?.includes(o.v)) opt.selected = true;
    sel.appendChild(opt);
  });
}

function addValue() {
    db.Classes[selectedIndex].Parameters[selectedParam].Values.push({ Value: "", Notes: "" });
    renderValues();
}

function removeValue(i) {
    db.Classes[selectedIndex].Parameters[selectedParam].Values.splice(i, 1);
    renderValues();
}

function saveParameter() {
  const c = db.Classes[selectedIndex];
  const p = c.Parameters[selectedParam];

  p.Name = pName.value;
  p.Games = Number(pGames.value);
  p.Needed = pNeeded.checked;
  p.Description = pDesc.value;

  // Values
  const rows = values.querySelectorAll(".valueRow");
  p.Values = [...rows].map(r => ({
    Value: r.children[0].value,
    Notes: r.children[1].value
  }));

  // Exclusives
  const sel = document.getElementById("pExclusives");
  const selected = [...sel.selectedOptions].map(o => o.value);

  if (selected.length > 0) {
    p.Exclusives = selected;
  } else {
    delete p.Exclusives;
  }
}


function deleteParameter() {
    if (!confirm("Delete parameter?")) return;
    delete db.Classes[selectedIndex].Parameters[selectedParam];
    paramEditor.innerHTML = "";
    renderParameters();
}

/* ================= DOWNLOAD ================= */

function downloadJSON() {
    const blob = new Blob([JSON.stringify(db, null, 2)], { type: "application/json" });
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = "objectdb.json";
    a.click();
}
</script>

</body>
</html>
